{-# language OverloadedStrings #-}

module DerivingTH (plugin) where

import Data.Bifunctor
import Data.Either
import Data.Foldable
import Data.Generics

import GHC.Hs
import GHC.Plugins
import GHC.Types.Name.Occurrence as NS

import Language.Haskell.TH.LanguageExtensions


--------------------------------------------------------------------------------
-- Main definitions
--------------------------------------------------------------------------------

plugin :: Plugin
plugin = defaultPlugin
  { pluginRecompile = purePlugin
  , dynflagsPlugin = \_opts -> pure . addExtensions
  , parsedResultAction = \_opts _summary -> pure . processModule
  }

addExtensions :: DynFlags -> DynFlags
addExtensions dflags = foldl' xopt_set dflags
  [ DerivingVia
  , TemplateHaskell
  , TemplateHaskellQuotes
  ]

processModule :: HsParsedModule -> HsParsedModule
processModule hpm@HsParsedModule{ hpm_module = L l hsm } = hpm
  { hpm_module = L l $ hsm
    { hsmodImports = internalImport : hsmodImports hsm
    , hsmodDecls = everywhere (mkT processDecls) $ hsmodDecls hsm
    }
  }

internalImport :: LImportDecl GhcPs
internalImport = gen $ ImportDecl
  { ideclExt = nxf
  , ideclSourceSrc = NoSourceText
  , ideclName = gen $ mkModuleName "DerivingTH.Internal"
  , ideclPkgQual = Nothing
  , ideclSource = NotBoot
  , ideclSafe = False
  , ideclQualified = QualifiedPre
  , ideclImplicit = True
  , ideclAs = Nothing
  , ideclHiding = Nothing
  }

--------------------------------------------------------------------------------
-- Process Declarations
--------------------------------------------------------------------------------

processDecls :: [LHsDecl GhcPs] -> [LHsDecl GhcPs]
processDecls = concatMap processDecl

processDecl :: LHsDecl GhcPs -> [LHsDecl GhcPs]
processDecl (L loc (DerivD _ derivDecl)) = [L loc $ processDerivDecl derivDecl]
processDecl decl@(L _ (TyClD _ (DataDecl _ tyname _ _ _))) =
  let (derivDecls, decl') = everywhereM (mkM $ processDerivClauses tyname) decl
  in decl' : derivDecls
processDecl decl = [decl]

processDerivDecl :: DerivDecl GhcPs -> HsDecl GhcPs
processDerivDecl (DerivDecl _ sigty strat _overlap)
  | isTemplate strat
  , HsWC _ (HsIB _ (L _ ty)) <- sigty
  , HsAppTy _ cls (L _ (HsTyVar _ NotPromoted tyname)) <- ty
  = makeSplice tyname cls
processDerivDecl derivDecl = DerivD nxf derivDecl

processDerivClauses
  :: Located RdrName
  -> [LHsDerivingClause GhcPs]
  -> ([LHsDecl GhcPs], [LHsDerivingClause GhcPs])
processDerivClauses tyname =
  first concat . partitionEithers . map (processDerivClause tyname)

processDerivClause
  :: Located RdrName
  -> LHsDerivingClause GhcPs
  -> Either [LHsDecl GhcPs] (LHsDerivingClause GhcPs)
processDerivClause tyname (L l (HsDerivingClause _ strat (L _ clss)))
  | isTemplate strat
  = Left $ L l . makeSplice tyname . hsib_body <$> clss
processDerivClause _tyname derivClause = Right derivClause

isTemplate :: Maybe (LDerivStrategy GhcPs) -> Bool
isTemplate (Just (L _ (ViaStrategy ty)))
  | (HsIB _ (L _ (HsTyVar _ NotPromoted (L _ (Unqual occ))))) <- ty
  = occNameFS occ == "template"
isTemplate _ = False

makeSplice :: Located RdrName -> LHsType GhcPs -> HsDecl GhcPs
makeSplice tyname cls = SpliceD nxf $ SpliceDecl nxf
  (gen $ HsUntypedSplice nxf DollarSplice (mkUnqual NS.varName "splice") $
     mkHsApps (internalVar NS.varName "deriveTH'") [proxy, name])
  ExplicitSplice
  where
    proxy = gen $ ExprWithTySig nxf (internalVar dataName "Proxy") $
      HsWC nxf $ HsIB nxf $ mkHsAppTy (internalTyVar tcName "Proxy") cls
    name = HsBracket nxf . VarBr nxf True <$> tyname


--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

nxf :: NoExtField
nxf = noExtField

gen :: a -> Located a
gen = L $ mkGeneralSrcSpan "<generated by deriving-th>"

internal :: NameSpace -> FastString -> Located RdrName
internal ns name = gen $ mkQual ns ("DerivingTH.Internal", name)

internalVar :: NameSpace -> FastString -> LHsExpr GhcPs
internalVar ns = gen . HsVar nxf . internal ns

internalTyVar :: NameSpace -> FastString -> LHsType GhcPs
internalTyVar ns = gen . HsTyVar nxf NotPromoted . internal ns
